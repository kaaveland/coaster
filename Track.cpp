#include <cmath>
#include <vector>
#include "Track.h"
#include "Vector3d.h"
#include "VectorTools.h"
#include <cassert>

#define NULL 0
#define DEBUG

#ifdef DEBUG
#include <iostream>
#endif

Track::Track(vector<Vector3d> const &pos, vector<Vector3d> const &up)
{
	assert(pos.size() == up.size());

	this->nPoints = pos.size();
	this->pos = pos;
	this->up = up;
}

Track::Track(int nPoints) {
	this->nPoints = nPoints;
	pos.resize(nPoints);
	up.resize(nPoints);

	this->generateTrack();
}

Track::~Track(void)
{
		
}

Vector3d Track::getPos(int index) const
{
	assert(index >= 0 && index < nPoints);

	return pos[index];
}

void Track::setPos(int index, Vector3d v)
{
	assert(index >= 0 && index < nPoints);

	//TODO: delete old?

	pos[index] = v;
}

Vector3d Track::getUp(int index) const
{
	assert(index >= 0 && index < nPoints);

	return up[index];
}

void Track::setUp(int index, Vector3d v)
{
	assert(index >= 0 && index < nPoints);
	
	//TODO: delete old?

	up[index] = v;
}

int inline Track::getSegmentIndex(double distance) const 
{
	// TODO: Possibility for interpolation if neccessary?
	// Note: For a track generated by makeParallelTrack ds will vary!
	
	// int index = (int)(distance/ds * nPoints) - 1;
	// if (index >= nPoints || index < 0) return -1;	// The distance lies before or after the track

	return -1;
}

double inline Track::getDistance(int index) const
{
	assert(index >= 0 && index < nPoints);

	// Possibly other calculation?
	// return ds*index;
	return -1.0;
}
Vector3d Track::getTangentVector(int index) const
{
	assert(index >= 0 && index < nPoints-1);

	Vector3d *pos0, *pos1;
	pos0 = &getPos(index);
	pos1 = &getPos(index+1);
		
	Vector3d diff = vectorDiff(*pos1, *pos0);
	double length = vectorLength(diff);

	Vector3d tangent;
	tangent.x = diff.x/length;
	tangent.y = diff.y/length;
	tangent.z = diff.z/length;

	return tangent;
}

double Track::getCurvature(int index) const
{
	assert(index >= 0 && index < nPoints-1);

	Vector3d *pos0, *pos1;
	pos0 = &getPos(index);
	pos1 = &getPos(index+1);
		
	Vector3d diff = vectorDiff(*pos1, *pos0);
	return vectorLength(diff);
}

Vector3d Track::getNormalVector(int index) const
{
	// TODO: assert that normal is not of inf length!
	assert(index >= 0 && index < nPoints);

	// We need one point back and one point forward for the normal vector, so on the boundaries we hack.
	if (index == 0) return getNormalVector(1);
	if (index == nPoints-1) return getNormalVector(nPoints-2);
	
	Vector3d T0, T1;
	T0 = getTangentVector(index-1);
	T1 = getTangentVector(index);
		
	// The normal vector points towards T1-T0
	Vector3d diff = vectorDiff(T1, T0);
	double length = vectorLength(diff);

	Vector3d normal;
	normal.x = diff.x/length;
	normal.y = diff.y/length;
	normal.z = diff.z/length;

	return normal;
}

void Track::generateTrack(void)
{

	const double PI = acos(-1.0);
	Vector3d v(0,0,0);

	
	for (int i = 0; i < this->nPoints; i++) {
		v.x = 5*i;
		v.y = 100+100*i;
		v.z = 50*i;
		this->setPos(i, v);
		
		v.x = 0.0;
		v.y = 0.0;
		v.z = 0.0;

		this->setUp(i, v);
	}
	
}

void Track::getParallelTrack(double offset, Track &track) const 
{
#ifdef DEBUG
	std::cout << "Generating data for parallel Track...";
#endif

	assert(nPoints == track.nPoints);
	
	Vector3d perpendicularVector, up, tangent;
	
	for (int i = 0; i < nPoints-1; i++) {	
		// Get the up and tangential vector for this section
		up = getUp(i);
		tangent = getTangentVector(i);
		
		// Calculate the cross product betwen these. This vector will point "to the left".
		perpendicularVector = vectorCross(up, tangent);

		// Divide by current length and multiply by offset to get correct length
		double length = vectorLength(perpendicularVector);
		perpendicularVector.x *= offset/length;
		perpendicularVector.y *= offset/length;
		perpendicularVector.z *= offset/length;

		// Calculate point coordinates for parallel track
		Vector3d newPoint = vectorSum(pos[i], perpendicularVector);

		// Insert new point into array
		track.pos[i] = newPoint;
	}

	// Up, normal and tangent vectors are assumed to be equal to this track. (Correct?)
	// Note: copied or referenced???
	track.up = this->up;
	
	
#ifdef DEBUG
	std::cout << "Done\n";
#endif

}

int Track::getNumberOfPoints(void) const
{
	return this->nPoints;
}
