#include <cmath>
#include "Track.h"
#include <cassert>

#define NULL 0
#define DEBUG

#ifdef DEBUG
#include <iostream>
#endif

// Calculates the vector difference v1-v0 and returns the length of the resulting vector
void inline vectorDiff(double const *v1, double const *v0, double *diff)
{
	double dx = v1[0]-v0[0];	// dx
	double dy = v1[1]-v0[1];	// dy
	double dz = v1[2]-v0[2];	// dz
	
	diff[0] = dx;
	diff[1] = dy;
	diff[2] = dz;
}

double inline vectorLength(double const *v) {
	return sqrt( pow(v[0],2) + pow(v[1],2) + pow(v[2],2) );
}

// Calculates the vector scalar (dot) product of v1 and v2 and returns the scalar
double inline vectorDot(double const *v0, double const *v1)
{
	return (v0[0]*v1[0] + v0[1]*v1[1] + v0[2]*v1[2]);
}

// Calculates the vector cross product of v0 and v1.
void inline vectorCross(double const *v0, double const *v1, double *cross) {
	cross[0] = v0[1]*v1[2] - v0[2]*v1[1];
	cross[1] = v0[2]*v1[0] - v0[0]*v1[2];
	cross[2] = v0[0]*v1[1] - v0[1]*v1[0];
}


Track::Track(double *pointsx, double *pointsy, double *pointsz, double *upx, double *upy, double *upz, int nPoints, double trackLength)
{
	isAllocatedDynamically = false;

	this->pointsx = pointsx;
	this->pointsy = pointsy;
	this->pointsz = pointsz;
	this->upx = upx;
	this->upy = upy;
	this->upz = upz;
	this->nPoints = nPoints;
	this->trackLength = trackLength;

	// The distance between each point. Note that in reality this might vary, and we have not yet decided
	// how this should be implemented.
	ds = trackLength/(nPoints-1);	
}

Track::Track(int nPoints) {

	this->nPoints = nPoints;
	pointsx = new double[nPoints];
	pointsy = new double[nPoints];
	pointsz = new double[nPoints];
	upx = new double[nPoints];
	upy = new double[nPoints];
	upz = new double[nPoints];

	// Note: calculate ds...
}

Track::~Track(void)
{
		delete [] pointsx;
		delete [] pointsy;
		delete [] pointsz;
		//delete [] upx;
		//delete [] upy;
		//delete [] upz;
	
		// OMG C++
}

void Track::getPos3d(int index, double *pos3d) const
{
	assert(index >= 0 && index < nPoints);

	pos3d[0] = pointsx[index];
	pos3d[1] = pointsy[index];
	pos3d[2] = pointsz[index];
}

void Track::getUp3d(int index, double *up3d) const
{
	assert(index >= 0 && index < nPoints);

	up3d[0] = upx[index];
	up3d[1] = upy[index];
	up3d[2] = upz[index];
}

int inline Track::getSegmentIndex(double distance) const 
{
	// TODO: Possibility for interpolation if neccessary?
	// Note: For a track generated by makeParallelTrack ds will vary!
	
	int index = (int)(distance/ds * nPoints) - 1;
	if (index >= nPoints || index < 0) return -1;	// The distance lies before or after the track

	return index;
}

double inline Track::getDistance(int index) const
{
	assert(index >= 0 && index < nPoints);

	// Possibly other calculation?
	return ds*index;
}

void Track::getTangentVector3d(int index, double *tangent3d) const
{
	assert(index >= 0 && index < nPoints-1);

	double pos0[3], pos1[3];
	getPos3d(index, pos0);
	getPos3d(index + 1, pos1);
		
	double diff[3];
	vectorDiff(pos1, pos0, diff); 
	double length = vectorLength(diff);

	tangent3d[0] = diff[0]/length;
	tangent3d[1] = diff[1]/length;
	tangent3d[2] = diff[2]/length;
}

void Track::getNormalVector3d(int index, double *normal3d) const
{
	// We need one point back and one point forward for the normal vector
	assert(index >= 1 && index < nPoints-1);

	double T0[3], T1[3];
	getTangentVector3d(index-1, T0);
	getTangentVector3d(index, T1);
		
	double diff[3];
	// The normal vector points towards T1-T0
	vectorDiff(T1, T0, diff);
	double length = vectorLength(diff);

	normal3d[0] = diff[0]/length;
	normal3d[1] = diff[1]/length;
	normal3d[2] = diff[2]/length;
}

void Track::getParallelTrack(double offset, Track &track) const 
{
#ifdef DEBUG
	std::cout << "Generating data for parallel Track...";
#endif
	
	assert(nPoints == track.nPoints);
	
	double perpendicularVector[3], up[3], tangent[3];
	
	for (int i = 0; i < nPoints-1; i++) {	
		// Get the up and tangential vector for this section
		getUp3d(i, up);
		getTangentVector3d(i, tangent);
		
		// Calculate the cross product betwen these. This vector will point "to the left".
		vectorCross(up, tangent, perpendicularVector);

		// Divide by current length and multiply by offset to get correct length
		double length = vectorLength(perpendicularVector);
		perpendicularVector[0] *= offset/length;
		perpendicularVector[1] *= offset/length;
		perpendicularVector[2] *= offset/length;

		// Calculate point coordinates for parallel track
		track.pointsx[i] = this->pointsx[i] + perpendicularVector[0];
		track.pointsy[i] = this->pointsy[i] + perpendicularVector[1];
		track.pointsz[i] = this->pointsz[i] + perpendicularVector[2];
	}

	// Up, normal and tangent vectors are assumed to be equal to this track. (Correct?)
	// Note: values are only referenced, not copied
	track.upx = upx;
	track.upy = upy;
	track.upz = upz;
	

#ifdef DEBUG
	std::cout << "Done\n";
#endif

}
