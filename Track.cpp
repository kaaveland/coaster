#include <cmath>
#include <vector>
#include "Track.h"
#include "Vector3d.h"
#include <cassert>

#define NULL 0
#define DEBUG

#ifdef DEBUG
#include <iostream>
#endif

Track::Track(vector<Vector3d> const &pos, vector<Vector3d> const &up)
{
	assert(pos.size() == up.size());

	this->nPoints = pos.size();
	this->pos = pos;
	this->up = up;
}

Track::Track(int nPoints) {
	this->nPoints = nPoints;
	pos.resize(nPoints);
	up.resize(nPoints);

	this->generateTrack();
}

Track::~Track(void)
{
		
}

Vector3d Track::getPos(int index) const
{
	assert(index >= 0 && index < nPoints);

	return pos[index];
}

void Track::setPos(int index, Vector3d v)
{
	assert(index >= 0 && index < nPoints);

	//TODO: delete old?

	pos[index] = v;
}

Vector3d Track::getUp(int index) const
{
	assert(index >= 0 && index < nPoints);

	return up[index];
}

void Track::setUp(int index, Vector3d v)
{
	assert(index >= 0 && index < nPoints);
	
	//TODO: delete old?

	up[index] = v;
}

int inline Track::getSegmentIndex(double distance) const 
{
	// TODO: Possibility for interpolation if neccessary?
	// Note: For a track generated by makeParallelTrack ds will vary!
	
	// int index = (int)(distance/ds * nPoints) - 1;
	// if (index >= nPoints || index < 0) return -1;	// The distance lies before or after the track

	//Interpolation code from: http://www.mvps.org/directx/articles/catmull/

	//http://www.ogre3d.org/docs/api/html/classOgre_1_1SimpleSpline.html#_details

	/*D3DXVECTOR3 CHighway::GetPos(float dist, BOOL bLinearInterpolate)
{
	// determine which segment we are on

	int segmentNum=(int) (dist/HIGHWAY_STRIP_LEN);

	// get position within that segment

	float pos=(dist-segmentNum*HIGHWAY_STRIP_LEN)/HIGHWAY_STRIP_LEN;

	// get control points p0,p1,p2,p3, where desired point between p1 and p2
	// allows for wraparound in both directions

	D3DXVECTOR3 p[4];
	for (int i=0;i<4;i++) {
		int s=segmentNum+i-1;
		D3DXVECTOR3 offset(0.0f,0.0f,0.0f);
		if (s<0) {
			offset=-m_endPos;
			s+=HIGHWAY_STRIPS-1;
		} else if (s>HIGHWAY_STRIPS-1) {
			offset=m_endPos;
			s-=HIGHWAY_STRIPS-1;
		}
		p[i]=m_centerVerts[s]+offset;
	}

	// interpolate position, using requested method

	D3DXVECTOR3 v;
	if (bLinearInterpolate) {
		D3DXVec3Lerp(&v,&p[1],&p[2],pos);
	} else {
		D3DXVec3CatmullRom(&v,
						   &p[0],
						   &p[1],
						   &p[2],
						   &p[3],
						   pos);
	}

	// return interpolated position

	return v;
}*/


	return -1;
}

double inline Track::getDistance(int index) const
{
	assert(index >= 0 && index < nPoints);

	// Possibly other calculation?
	// return ds*index;
	return -1.0;
}
Vector3d Track::getTangentVector(int index) const
{
	assert(index >= 0 && index < nPoints-1);

	Vector3d *pos0, *pos1;
	pos0 = &getPos(index);
	pos1 = &getPos(index+1);
		
	Vector3d tangent = *pos1 - *pos0;
	double length = tangent.length();
	tangent /= length;
	
	return tangent;
}

double Track::getCurvature(int index) const
{
	assert(index >= 0 && index < nPoints-1);

	Vector3d *pos0, *pos1;
	pos0 = &getPos(index);
	pos1 = &getPos(index+1);
		
	Vector3d diff = *pos1 - *pos0;
	return diff.length();
}

Vector3d Track::getNormalVector(int index) const
{
	// TODO: assert that normal is not of inf length!
	assert(index >= 0 && index < nPoints);

	// We need one point back and one point forward for the normal vector, so on the boundaries we hack.
	if (index == 0) return getNormalVector(1);
	if (index == nPoints-1) return getNormalVector(nPoints-2);
	
	Vector3d T0, T1;
	T0 = getTangentVector(index-1);
	T1 = getTangentVector(index);
		
	// The normal vector points towards T1-T0
	Vector3d normal = T1 - T0;
	double length = normal.length();
	normal /= length;
	
	return normal;
}

void Track::generateTrack(void)
{

	const double PI = acos(-1.0);
	Vector3d v(0,0,0);
	Vector3d v_0(0,0,0);

	v.x = 0;
	v.z = 20;
	this->setPos(0, v);
	this->setUp(0, v_0);

	v.x = 20;
	v.z = 0;
	this->setPos(1, v);
	this->setUp(0, v_0);

	v.x = 0;
	v.z = -20;
	this->setPos(2, v);
	this->setUp(0, v_0);

	v.x = -20;
	v.y = 20;
	v.z = 0;
	this->setPos(3, v);
	this->setUp(0, v_0);

	v.x = 10;
	v.y = -20;
	v.z = 20;
	this->setPos(4, v);
	this->setUp(0, v_0);

	v.x = 40;
	v.y = -60;
	v.z = 40;
	this->setPos(5, v);
	this->setUp(0, v_0);


	/*
	for (int i = 0; i < this->nPoints; i++) {
		v.x = 5*i;
		v.y = 100;
		v.z = v.z*2;
		this->setPos(i, v);

		this->setUp(i, v_0);
	}
	*/
	
}

void Track::getParallelTrack(double offset, Track &track) const 
{
#ifdef DEBUG
	std::cout << "Generating data for parallel Track...";
#endif

	assert(nPoints == track.nPoints);
	
	Vector3d perpendicularVector, up, tangent;
	
	for (int i = 0; i < nPoints-1; i++) {	
		// Get the up and tangential vector for this section
		up = getUp(i);
		tangent = getTangentVector(i);
		
		// Calculate the cross product betwen these. This vector will point "to the left".
		perpendicularVector = up.cross(tangent);

		// Divide by current length and multiply by the offset to get correct length
		double length = perpendicularVector.length();
		perpendicularVector *= offset/length;
	
		// Calculate point coordinates for parallel track
		Vector3d newPoint = this->pos[i] + perpendicularVector;

		// Insert new point into array
		track.pos[i] = newPoint;

		// Up, normal and tangent vectors are assumed to be equal to this track. (Correct?)
		track.up[i] = this->up[i];
	}
		
#ifdef DEBUG
	std::cout << "Done\n";
#endif

}

int Track::getNumberOfPoints(void) const
{
	return this->nPoints;
}
