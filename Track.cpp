#include <cmath>
#include <vector>
#include "Track.h"
#include "Vector3d.h"
#include <cassert>

#define NULL 0
#define DEBUG

#ifdef DEBUG
#include <iostream>
#endif

Vector3d inline vectorSum(Vector3d const &v0, Vector3d const &v1)
{
	double dx = v0.x+v1.x;	// dx
	double dy = v0.y+v1.y;	// dy
	double dz = v0.z+v1.z;	// dz
	
	return Vector3d(dx,dy,dz);
}

// Calculates and returns the vector difference v1-v0 
Vector3d inline vectorDiff(Vector3d const &v1, Vector3d const &v0)
{
	double dx = v1.x-v0.x;	// dx
	double dy = v1.y-v0.y;	// dy
	double dz = v1.z-v0.z;	// dz
	
	return Vector3d(dx,dy,dz);
}

double inline vectorLength(Vector3d const &v) {
	return sqrt( pow(v.x, 2) + pow(v.y, 2) + pow(v.z, 2) );
}

// Calculates the vector scalar (dot) product of v1 and v2 and returns the scalar
double inline vectorDot(Vector3d const &v0, Vector3d const &v1)
{
	return (v0.x*v1.x + v0.y*v1.y + v0.z*v1.z);
}

// Calculates the vector cross product of v0 and v1.
Vector3d inline vectorCross(Vector3d const &v0, Vector3d const &v1) {
	double x = v0.y*v1.z - v0.z*v1.y;
	double y = v0.z*v1.x - v0.x*v1.z;
	double z = v0.x*v1.y - v0.y*v1.x;
	return Vector3d(x,y,z);
}


Track::Track(vector<Vector3d> const &pos, vector<Vector3d> const &up)
{
	assert(pos.size() == up.size());

	this->nPoints = pos.size();
	this->pos = pos;
	this->up = up;
}

Track::Track(int nPoints) {
	this->nPoints = nPoints;
	pos.resize(nPoints);
	up.resize(nPoints);
}

Track::~Track(void)
{
		
}

Vector3d Track::getPos(int index) const
{
	assert(index >= 0 && index < nPoints);

	return pos[index];
}

Vector3d Track::getUp(int index) const
{
	assert(index >= 0 && index < nPoints);

	return up[index];
}

int inline Track::getSegmentIndex(double distance) const 
{
	// TODO: Possibility for interpolation if neccessary?
	// Note: For a track generated by makeParallelTrack ds will vary!
	
	// int index = (int)(distance/ds * nPoints) - 1;
	// if (index >= nPoints || index < 0) return -1;	// The distance lies before or after the track

	return -1;
}

double inline Track::getDistance(int index) const
{
	assert(index >= 0 && index < nPoints);

	// Possibly other calculation?
	// return ds*index;
	return -1.0;
}
Vector3d Track::getTangentVector(int index) const
{
	assert(index >= 0 && index < nPoints-1);

	Vector3d pos0, pos1;
	pos0 = getPos(index);
	pos1 = getPos(index+1);
		
	Vector3d diff = vectorDiff(pos1, pos0);
	double length = vectorLength(diff);

	Vector3d tangent;
	tangent.x = diff.x/length;
	tangent.y = diff.y/length;
	tangent.z = diff.z/length;

	return tangent;
}

Vector3d Track::getNormalVector(int index) const
{
	// TODO: assert that normal is not of inf length!

	// We need one point back and one point forward for the normal vector
	assert(index >= 1 && index < nPoints-1);

	Vector3d T0, T1;
	T0 = getTangentVector(index-1);
	T1 = getTangentVector(index);
		
	// The normal vector points towards T1-T0
	Vector3d diff = vectorDiff(T1, T0);
	double length = vectorLength(diff);

	Vector3d normal;
	normal.x = diff.x/length;
	normal.y = diff.y/length;
	normal.z = diff.z/length;

	return normal;
}

void Track::getParallelTrack(double offset, Track &track) const 
{
#ifdef DEBUG
	std::cout << "Generating data for parallel Track...";
#endif
	
	assert(nPoints == track.nPoints);
	
	Vector3d perpendicularVector, up, tangent;
	
	for (int i = 0; i < nPoints-1; i++) {	
		// Get the up and tangential vector for this section
		up = getUp(i);
		tangent = getTangentVector(i);
		
		// Calculate the cross product betwen these. This vector will point "to the left".
		perpendicularVector = vectorCross(up, tangent);

		// Divide by current length and multiply by offset to get correct length
		double length = vectorLength(perpendicularVector);
		perpendicularVector.x *= offset/length;
		perpendicularVector.y *= offset/length;
		perpendicularVector.z *= offset/length;

		// Calculate point coordinates for parallel track
		Vector3d newPoint = vectorSum(pos[i], perpendicularVector);

		// Insert new point into array
		track.pos[i] = newPoint;
	}

	// Up, normal and tangent vectors are assumed to be equal to this track. (Correct?)
	// Note: copied or referenced???
	track.up = this->up;
	
#ifdef DEBUG
	std::cout << "Done\n";
#endif

}
